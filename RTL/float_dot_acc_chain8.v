// Copyright 2010-2019 Altera Corporation. All rights reserved.
// Altera products are protected under numerous U.S. and foreign patents, 
// maskwork rights, copyrights and other intellectual property laws.  
//
// This reference design file, and your use thereof, is subject to and governed
// by the terms and conditions of the applicable Altera Reference Design 
// License Agreement (either as signed by you or found at www.altera.com).  By
// using this reference design file, you indicate your acceptance of such terms
// and conditions between you and Altera Corporation.  In the event that you do
// not agree with such terms and conditions, you may not use the reference 
// design file and please promptly destroy any copies you have made.
//
// This reference design file is being provided on an "as-is" basis and as an 
// accommodation and therefore all warranties, representations or guarantees of 
// any kind (whether express, implied or statutory) including, without 
// limitation, warranties of merchantability, non-infringement, or fitness for
// a particular purpose, are specifically disclaimed.  By making this reference
// design file available, Altera expressly does not recommend, suggest or 
// require that this reference design file be used in combination with any 
// other product not provided by Altera.
/////////////////////////////////////////////////////////////////////////////

`timescale 1ps/1ps

// Generated by one of Gregg's toys.   Share And Enjoy.
// Executable compiled Sep 14 2017 14:08:59
// This file was generated 01/18/2019 7:50:54

module float_dot_acc_chain8 (
    input clk,
    input [31:0] acc,
    input [31:0] dina0,
    input [31:0] dina1,
    input [31:0] dinb0,
    input [31:0] dinb1,
    input [31:0] dinc0,
    input [31:0] dinc1,
    input [31:0] dind0,
    input [31:0] dind1,
    input [31:0] dine0,
    input [31:0] dine1,
    input [31:0] dinf0,
    input [31:0] dinf1,
    input [31:0] ding0,
    input [31:0] ding1,
    input [31:0] dinh0,
    input [31:0] dinh1,

    output [31:0] dout
);

///////////////////////////////////////////////////////////////
// s10 dsp block cheat sheet

// (roughly) the register pattern of the hardware cell
//
//       |----|        |chain        regs     |-----|    |-----|
//  ax   |    | -------mx ------  [axc] [2nd]-| add | +  | out | --
//       | in | ------------------------------| reg |    | reg |
//       | reg|                         |-----|-----|  |-|-----|
//  ay   |    |        regs             |              |
//  az   |    |  *  [mult] [2nd]  ------|--------------|
//       |----|
//
// Pipeline -- 
// shut off mult_pipeline before 2nd multpipeline
// shut off ax_chainin_pl before 2nd
// don't shut off in or out


// Multiply
//   .operation_mode("sp_mult"),
//   resulta = AY*AZ
//   chainout = same

// Multiply Add
//   .operation_mode("sp_mult_add"),
//   resulta = AY*AZ + chain_in   or +AX
//   chainout = same

// VECTOR 1
//   .operation_mode("sp_vector1"),
//   resulta = AY*AZ + chain_in
//   chainout = AX

// VECTOR 2
//   .operation_mode("sp_vector2"),
//   resulta = AX + chain_in
//   chainout = AY * AZ

// note - "0" means clock[0],  "none" means unregistered
///////////////////////////////////////////////////////////////


///////////////////////////////////////////////////
// chain pattern

//0 a0*a1
//        V
//1 b0*b1    +  
//        V
//  fbk		+ => dout1    
//2 c0*c1    
//        V
//3 d0*d1    + => fbk
//  dout1--  
// 		 V
//  dout2 ----+ => dout
//4 e0*e1
//        V
//5 f0*f1    +  
//        V
//  fbk2		+ => dout2    
//6 g0*g1    
//        V
//7 h0*h1    + => fbk2

wire [31:0] dout1;
wire [31:0] dout2;

//////////////////////
// acbd

wire [31:0] chainout_0;

fourteennm_fp_mac #( 
	.operation_mode("sp_mult_add"),
	.use_chainin("false"),
	
	.ax_clock("0"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("none"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("0"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("none"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac0 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
    .ax(acc),
    
    .ay(dina0),
    .accumulate(1'b0),
    .chainin(32'h0),
    .az(dina1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(),
    .chainout(chainout_0),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

wire [31:0] chainout_1;

fourteennm_fp_mac #( 
	.operation_mode("sp_mult_add"),
	.use_chainin("true"),
	
	.ax_clock("none"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("none"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("0"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac1 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
  // synthesis translate_off
    .ax(32'h0),
  // synthesis translate_on
    
    .ay(dinb0),
    .accumulate(1'b0),
    .chainin(chainout_0),
    .az(dinb1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(),
    .chainout(chainout_1),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

wire [31:0] feedback;

wire [31:0] chainout_2;

fourteennm_fp_mac #( 
	.operation_mode("sp_vector2"),
	.use_chainin("true"),
	
	.ax_clock("0"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("0"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("none"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac2 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
    .ax(feedback),
    
    .ay(dinc0),
    .accumulate(1'b0),
    .chainin(chainout_1),
    .az(dinc1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(dout1),
    .chainout(chainout_2),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

wire [31:0] chainout_3;

fourteennm_fp_mac #( 
	.operation_mode("sp_vector1"),
	.use_chainin("true"),
	
	.ax_clock("0"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("none"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("0"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac3 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
    .ax(dout1),
    
    .ay(dind0),
    .accumulate(1'b0),
    .chainin(chainout_2),
    .az(dind1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(feedback),
    .chainout(chainout_3),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

//////////////////////
// efgh

wire [31:0] chainout_4;

fourteennm_fp_mac #( 
	.operation_mode("sp_vector2"),
	.use_chainin("true"),
	
	.ax_clock("0"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("none"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("none"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac4 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
    .ax(dout2),
    
    .ay(dine0),
    .accumulate(1'b0),
    .chainin(chainout_3),
    .az(dine1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(dout),
    .chainout(chainout_4),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

wire [31:0] chainout_5;

fourteennm_fp_mac #( 
	.operation_mode("sp_mult_add"),
	.use_chainin("true"),
	
	.ax_clock("none"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("none"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("0"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac5 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
  // synthesis translate_off
    .ax(32'h0),
  // synthesis translate_on
    
    .ay(dinf0),
    .accumulate(1'b0),
    .chainin(chainout_4),
    .az(dinf1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(),
    .chainout(chainout_5),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

wire [31:0] feedback2;

wire [31:0] chainout_6;

fourteennm_fp_mac #( 
	.operation_mode("sp_vector2"),
	.use_chainin("true"),
	
	.ax_clock("0"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("0"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("none"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac6 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
    .ax(feedback2),
    
    .ay(ding0),
    .accumulate(1'b0),
    .chainin(chainout_5),
    .az(ding1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(dout2),
    .chainout(chainout_6),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

wire [31:0] chainout_7;

fourteennm_fp_mac #( 
	.operation_mode("sp_mult_add"),
	.use_chainin("true"),
	
	.ax_clock("none"),
	
	.ay_clock("0"),
	.az_clock("0"),
	
	.clear_type("none"),
		
	.adder_input_clock("0"),
	
	.ax_chainin_pl_clock("none"),
	.ax_chainin_2nd_pl_clock("none"),
		
	.accum_adder_clock("none"),
	.accum_pipeline_clock("none"),
	.accum_2nd_pipeline_clock("none"),
	.accumulate_clock("none"),
	
	.mult_pipeline_clock("0"),
	.mult_2nd_pipeline_clock("0"),
	
	.output_clock("0")		
	
) mac7 (
    // Input
    .clr(2'b0),
    .clk({2'b0,clk}),
    .ena({2'b0,1'b1}),
  
  // synthesis translate_off
    .ax(32'h0),
  // synthesis translate_on
    
    .ay(dinh0),
    .accumulate(1'b0),
    .chainin(chainout_6),
    .az(dinh1),
  
  // synthesis translate_off
    .dfxlfsrena(1'b0),
    .dfxmisrena(1'b0),
  // synthesis translate_on
  
    // Output
    .resulta(feedback2),
    .chainout(chainout_7),
    .adder_inexact(),
    .adder_invalid(),
    .adder_overflow(),
    .adder_underflow(),
    .mult_inexact(),
    .mult_invalid(),
    .mult_overflow(),
    .mult_underflow(),
    .dftout()
);

endmodule

